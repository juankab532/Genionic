/**
 * generated by Xtext
 */
package co.edu.javeriana.isml.scoping;

import co.edu.javeriana.isml.isml.Action;
import co.edu.javeriana.isml.isml.ActionCall;
import co.edu.javeriana.isml.isml.Assignment;
import co.edu.javeriana.isml.isml.Attribute;
import co.edu.javeriana.isml.isml.Controller;
import co.edu.javeriana.isml.isml.Entity;
import co.edu.javeriana.isml.isml.Function;
import co.edu.javeriana.isml.isml.Interface;
import co.edu.javeriana.isml.isml.MethodCall;
import co.edu.javeriana.isml.isml.Parameter;
import co.edu.javeriana.isml.isml.Reference;
import co.edu.javeriana.isml.isml.Service;
import co.edu.javeriana.isml.isml.Type;
import co.edu.javeriana.isml.isml.TypeSpecification;
import co.edu.javeriana.isml.isml.Variable;
import co.edu.javeriana.isml.isml.VariableReference;
import co.edu.javeriana.isml.isml.VariableTypeElement;
import co.edu.javeriana.isml.scoping.IsmlModelNavigation;
import co.edu.javeriana.isml.scoping.ScopeExtension;
import co.edu.javeriana.isml.validation.TypeChecker;
import com.google.common.base.Objects;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import javax.inject.Inject;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.util.PolymorphicDispatcher;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it
 */
@SuppressWarnings("all")
public class IsmlScopeProvider extends AbstractDeclarativeScopeProvider {
  @Inject
  @Extension
  private IsmlModelNavigation _ismlModelNavigation;
  
  @Inject
  @Extension
  private TypeChecker _typeChecker;
  
  @Inject
  @Extension
  private IQualifiedNameProvider _iQualifiedNameProvider;
  
  @Inject
  @Extension
  private ScopeExtension _scopeExtension;
  
  @Override
  protected Predicate<Method> getPredicate(final EObject context, final EReference reference) {
    String _name = context.eClass().getName();
    String _plus = ("scope_" + _name);
    String _plus_1 = (_plus + "_");
    String _name_1 = reference.getName();
    final String methodName = (_plus_1 + _name_1);
    return PolymorphicDispatcher.Predicates.forName(methodName, 2);
  }
  
  public IScope scope_VariableReference_referencedElement(final VariableReference r, final EReference ref) {
    try {
      final ArrayList<EObject> referencedVariables = new ArrayList<EObject>();
      final Iterable<EObject> allElementsInScope = this._scopeExtension.getAllElementsInScope(r);
      Iterables.<EObject>addAll(referencedVariables, Iterables.<Parameter>filter(allElementsInScope, Parameter.class));
      Iterables.<EObject>addAll(referencedVariables, Iterables.<Variable>filter(allElementsInScope, Variable.class));
      final Controller containerController = this._ismlModelNavigation.getContainerController(r);
      boolean _notEquals = (!Objects.equal(containerController, null));
      if (_notEquals) {
        referencedVariables.addAll(this._ismlModelNavigation.getAllFeatures(containerController));
      }
      final EObject parent = r.eContainer();
      boolean _matched = false;
      if (parent instanceof VariableReference) {
        _matched=true;
        VariableTypeElement _referencedElement = ((VariableReference)parent).getReferencedElement();
        Type _type = null;
        if (_referencedElement!=null) {
          _type=_referencedElement.getType();
        }
        final Type parentType = _type;
        TypeSpecification _typeSpecification = null;
        if (parentType!=null) {
          _typeSpecification=this._ismlModelNavigation.getTypeSpecification(parentType);
        }
        final TypeSpecification parentClassifier = _typeSpecification;
        boolean _notEquals_1 = (!Objects.equal(parentClassifier, null));
        if (_notEquals_1) {
          referencedVariables.addAll(this._ismlModelNavigation.getAllFeatures(parentClassifier));
        }
      }
      if (!_matched) {
        if (parent instanceof Type) {
          _matched=true;
          final TypeSpecification parentClassifier = this._ismlModelNavigation.getTypeSpecification(((Type)parent));
          boolean _notEquals_1 = (!Objects.equal(parentClassifier, null));
          if (_notEquals_1) {
            referencedVariables.addAll(this._ismlModelNavigation.getAllFeatures(parentClassifier));
          }
        }
      }
      return Scopes.scopeFor(referencedVariables);
    } catch (final Throwable _t) {
      if (_t instanceof Throwable) {
        final Throwable t = (Throwable)_t;
        t.printStackTrace();
        return null;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  public IScope scope_ResourceReference_referencedElement(final Reference r, final EReference ref) {
    final IScope scopes = this.getScope(r.eContainer(), ref);
    return scopes;
  }
  
  public IScope scope_MethodCall_referencedElement(final MethodCall call, final EReference ref) {
    final EObject parent = call.eContainer();
    final ArrayList<EObject> scopes = new ArrayList<EObject>();
    boolean _matched = false;
    if (parent instanceof Reference) {
      _matched=true;
      final Type parentType = this._typeChecker.getType(((Reference)parent).getReferencedElement());
      final TypeSpecification parentClassifier = this._ismlModelNavigation.getTypeSpecification(parentType);
      if ((parentClassifier instanceof Interface)) {
        final Function1<co.edu.javeriana.isml.isml.Method, Boolean> _function = (co.edu.javeriana.isml.isml.Method method) -> {
          return Boolean.valueOf(this._typeChecker.isCongruentWith(method, call));
        };
        Iterables.<EObject>addAll(scopes, IterableExtensions.<co.edu.javeriana.isml.isml.Method>filter(this._ismlModelNavigation.getAllMethods(((Interface)parentClassifier)), _function));
      }
      return Scopes.scopeFor(scopes);
    }
    {
      final Service containerService = this._ismlModelNavigation.<MethodCall, Service>findAncestor(call, Service.class);
      boolean _notEquals = (!Objects.equal(containerService, null));
      if (_notEquals) {
        final Function1<co.edu.javeriana.isml.isml.Method, Boolean> _function = (co.edu.javeriana.isml.isml.Method method) -> {
          return Boolean.valueOf(this._typeChecker.isCongruentWith(method, call));
        };
        Iterables.<EObject>addAll(scopes, IterableExtensions.<co.edu.javeriana.isml.isml.Method>filter(this._ismlModelNavigation.getAllMethods(containerService), _function));
      }
      Iterable<Service> _unnamedServices = this._ismlModelNavigation.getUnnamedServices(call);
      for (final Service service : _unnamedServices) {
        String _name = service.getName();
        boolean _equals = Objects.equal(_name, null);
        if (_equals) {
          final Function1<co.edu.javeriana.isml.isml.Method, Boolean> _function_1 = (co.edu.javeriana.isml.isml.Method method) -> {
            return Boolean.valueOf(this._typeChecker.isCongruentWith(method, call));
          };
          Iterables.<EObject>addAll(scopes, IterableExtensions.<co.edu.javeriana.isml.isml.Method>filter(this._ismlModelNavigation.getAllMethods(service), _function_1));
        }
      }
      return Scopes.scopeFor(scopes);
    }
  }
  
  public IScope scope_ActionCall_referencedElement(final ActionCall caller, final EReference ref) {
    IScope scope = IScope.NULLSCOPE;
    try {
      final Collection<Controller> controllers = this._ismlModelNavigation.<Controller>getAllInstances(caller.eResource().getResourceSet(), Controller.class);
      final Function1<Controller, Iterable<Action>> _function = (Controller it) -> {
        return this._ismlModelNavigation.getActions(it);
      };
      final Iterable<Action> candidateActions = Iterables.<Action>concat(IterableExtensions.<Controller, Iterable<Action>>map(controllers, _function));
      final Iterable<? extends Function> actions = this._typeChecker.filterCongruent(candidateActions, caller);
      final com.google.common.base.Function<Function, QualifiedName> _function_1 = (Function x) -> {
        return QualifiedName.create(this._ismlModelNavigation.getContainerController(x).getName()).append(x.getName());
      };
      scope = Scopes.<Function>scopeFor(actions, _function_1, scope);
      final Controller controller = this._ismlModelNavigation.getContainerController(caller);
      boolean _notEquals = (!Objects.equal(controller, null));
      if (_notEquals) {
        scope = Scopes.scopeFor(this._typeChecker.filterCongruent(this._ismlModelNavigation.getActions(controller), caller), scope);
      }
    } catch (final Throwable _t) {
      if (_t instanceof Throwable) {
        final Throwable t = (Throwable)_t;
        t.printStackTrace();
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    return scope;
  }
  
  public IScope scope_Assignment_element(final Assignment a, final EReference ref) {
    final ArrayList<EObject> scopes = new ArrayList<EObject>();
    scopes.addAll(this._ismlModelNavigation.getAllFeatures(this._ismlModelNavigation.getContainerController(a)));
    return Scopes.scopeFor(scopes);
  }
  
  public IScope scope_Attribute_opposite(final Attribute a, final EReference ref) {
    final Entity oppositeEntity = this._ismlModelNavigation.getOppositeEntity(a);
    boolean _notEquals = (!Objects.equal(oppositeEntity, null));
    if (_notEquals) {
      final EObject entity = a.eContainer();
      if ((entity instanceof Entity)) {
        final HashSet<Attribute> opposites = new HashSet<Attribute>();
        Iterable<Attribute> _allAttributes = this._ismlModelNavigation.getAllAttributes(oppositeEntity);
        for (final Attribute op : _allAttributes) {
          {
            final Entity opTypeSpec = this._ismlModelNavigation.findEntityTypeSpec(op.getType());
            if (((!Objects.equal(opTypeSpec, null)) && this._iQualifiedNameProvider.getFullyQualifiedName(opTypeSpec).equals(this._iQualifiedNameProvider.getFullyQualifiedName(entity)))) {
              opposites.add(op);
            }
          }
        }
        return Scopes.scopeFor(opposites);
      }
    }
    return IScope.NULLSCOPE;
  }
  
  public boolean is(final IEObjectDescription desc, final Class<? extends EObject> c) {
    return c.isInstance(desc.getEObjectOrProxy());
  }
}
