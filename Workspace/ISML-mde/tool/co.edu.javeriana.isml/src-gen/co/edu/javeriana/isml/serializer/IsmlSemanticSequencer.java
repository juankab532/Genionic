/*
 * generated by Xtext
 */
package co.edu.javeriana.isml.serializer;

import co.edu.javeriana.isml.isml.ActionCall;
import co.edu.javeriana.isml.isml.Actor;
import co.edu.javeriana.isml.isml.Assignment;
import co.edu.javeriana.isml.isml.Attribute;
import co.edu.javeriana.isml.isml.BinaryOperator;
import co.edu.javeriana.isml.isml.BoolValue;
import co.edu.javeriana.isml.isml.Constraint;
import co.edu.javeriana.isml.isml.ConstraintInstance;
import co.edu.javeriana.isml.isml.Controller;
import co.edu.javeriana.isml.isml.DTO;
import co.edu.javeriana.isml.isml.Entity;
import co.edu.javeriana.isml.isml.EnumItem;
import co.edu.javeriana.isml.isml.FloatValue;
import co.edu.javeriana.isml.isml.For;
import co.edu.javeriana.isml.isml.ForView;
import co.edu.javeriana.isml.isml.GenericTypeSpecification;
import co.edu.javeriana.isml.isml.If;
import co.edu.javeriana.isml.isml.IfView;
import co.edu.javeriana.isml.isml.Import;
import co.edu.javeriana.isml.isml.InformationSystem;
import co.edu.javeriana.isml.isml.IntValue;
import co.edu.javeriana.isml.isml.IsmlPackage;
import co.edu.javeriana.isml.isml.Method;
import co.edu.javeriana.isml.isml.MethodCall;
import co.edu.javeriana.isml.isml.NamedViewBlock;
import co.edu.javeriana.isml.isml.NullValue;
import co.edu.javeriana.isml.isml.Page;
import co.edu.javeriana.isml.isml.ParameterizedType;
import co.edu.javeriana.isml.isml.Primitive;
import co.edu.javeriana.isml.isml.Resource;
import co.edu.javeriana.isml.isml.ResourceAssignment;
import co.edu.javeriana.isml.isml.ResourceBundle;
import co.edu.javeriana.isml.isml.ResourceReference;
import co.edu.javeriana.isml.isml.Service;
import co.edu.javeriana.isml.isml.Show;
import co.edu.javeriana.isml.isml.StringValue;
import co.edu.javeriana.isml.isml.StructInstance;
import co.edu.javeriana.isml.isml.Type;
import co.edu.javeriana.isml.isml.UnaryOperator;
import co.edu.javeriana.isml.isml.Variable;
import co.edu.javeriana.isml.isml.VariableReference;
import co.edu.javeriana.isml.isml.ViewInstance;
import co.edu.javeriana.isml.isml.While;
import co.edu.javeriana.isml.isml.Widget;
import co.edu.javeriana.isml.services.IsmlGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class IsmlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private IsmlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == IsmlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case IsmlPackage.ACTION:
				sequence_Action(context, (co.edu.javeriana.isml.isml.Action) semanticObject); 
				return; 
			case IsmlPackage.ACTION_CALL:
				sequence_ActionCall(context, (ActionCall) semanticObject); 
				return; 
			case IsmlPackage.ACTOR:
				sequence_Actor(context, (Actor) semanticObject); 
				return; 
			case IsmlPackage.ASSIGNMENT:
				sequence_ReferenceStatement(context, (Assignment) semanticObject); 
				return; 
			case IsmlPackage.ATTRIBUTE:
				if (rule == grammarAccess.getAttributeRule()) {
					sequence_Attribute(context, (Attribute) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDTOAttributeRule()) {
					sequence_DTOAttribute(context, (Attribute) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFeatureRule()
						|| rule == grammarAccess.getServiceAttributeRule()) {
					sequence_ServiceAttribute(context, (Attribute) semanticObject); 
					return; 
				}
				else break;
			case IsmlPackage.BINARY_OPERATOR:
				sequence_ArithmeticExpression_BoolTerm_Comparison_Expression_Term(context, (BinaryOperator) semanticObject); 
				return; 
			case IsmlPackage.BOOL_VALUE:
				sequence_BoolValue(context, (BoolValue) semanticObject); 
				return; 
			case IsmlPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case IsmlPackage.CONSTRAINT_INSTANCE:
				sequence_ConstraintInstance(context, (ConstraintInstance) semanticObject); 
				return; 
			case IsmlPackage.CONTROLLER:
				sequence_Controller(context, (Controller) semanticObject); 
				return; 
			case IsmlPackage.DTO:
				sequence_DTO(context, (DTO) semanticObject); 
				return; 
			case IsmlPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case IsmlPackage.ENUM:
				sequence_Enum(context, (co.edu.javeriana.isml.isml.Enum) semanticObject); 
				return; 
			case IsmlPackage.ENUM_ITEM:
				sequence_EnumItem(context, (EnumItem) semanticObject); 
				return; 
			case IsmlPackage.FLOAT_VALUE:
				sequence_FloatValue(context, (FloatValue) semanticObject); 
				return; 
			case IsmlPackage.FOR:
				sequence_For(context, (For) semanticObject); 
				return; 
			case IsmlPackage.FOR_VIEW:
				sequence_ForView(context, (ForView) semanticObject); 
				return; 
			case IsmlPackage.GENERIC_TYPE_SPECIFICATION:
				sequence_GenericTypeSpecification(context, (GenericTypeSpecification) semanticObject); 
				return; 
			case IsmlPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case IsmlPackage.IF_VIEW:
				sequence_IfView(context, (IfView) semanticObject); 
				return; 
			case IsmlPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case IsmlPackage.INFORMATION_SYSTEM:
				sequence_InformationSystem(context, (InformationSystem) semanticObject); 
				return; 
			case IsmlPackage.INT_VALUE:
				sequence_IntValue(context, (IntValue) semanticObject); 
				return; 
			case IsmlPackage.METHOD:
				if (rule == grammarAccess.getNativeMethodRule()) {
					sequence_NativeMethod(context, (Method) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFeatureRule()
						|| rule == grammarAccess.getMethodRule()
						|| rule == grammarAccess.getFunctionRule()) {
					sequence_NativeMethod_RegularMethod(context, (Method) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRegularMethodRule()) {
					sequence_RegularMethod(context, (Method) semanticObject); 
					return; 
				}
				else break;
			case IsmlPackage.METHOD_CALL:
				if (rule == grammarAccess.getMethodCallRule()) {
					sequence_MethodCall(context, (MethodCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMethodStatementRule()
						|| rule == grammarAccess.getReferenceStatementRule()
						|| action == grammarAccess.getReferenceStatementAccess().getAssignmentLeftAction_1_0()
						|| rule == grammarAccess.getExpressionRule()
						|| action == grammarAccess.getExpressionAccess().getBinaryOperatorLeftAction_1_0()
						|| rule == grammarAccess.getBoolTermRule()
						|| action == grammarAccess.getBoolTermAccess().getBinaryOperatorLeftAction_1_0()
						|| rule == grammarAccess.getNegationRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getBinaryOperatorLeftAction_1_0()
						|| rule == grammarAccess.getArithmeticExpressionRule()
						|| action == grammarAccess.getArithmeticExpressionAccess().getBinaryOperatorLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getBinaryOperatorLeftAction_1_0()
						|| rule == grammarAccess.getNegativeRule()
						|| rule == grammarAccess.getFactorRule()
						|| rule == grammarAccess.getReferenceRule()
						|| rule == grammarAccess.getTypedElementReferenceRule()
						|| rule == grammarAccess.getReferenceTailRule()) {
					sequence_MethodCall_TypedElementReference(context, (MethodCall) semanticObject); 
					return; 
				}
				else break;
			case IsmlPackage.NAMED_VIEW_BLOCK:
				sequence_NamedViewBlock(context, (NamedViewBlock) semanticObject); 
				return; 
			case IsmlPackage.NULL_VALUE:
				sequence_NullValue(context, (NullValue) semanticObject); 
				return; 
			case IsmlPackage.PACKAGE:
				sequence_Package(context, (co.edu.javeriana.isml.isml.Package) semanticObject); 
				return; 
			case IsmlPackage.PAGE:
				sequence_Page(context, (Page) semanticObject); 
				return; 
			case IsmlPackage.PARAMETER:
				sequence_Parameter(context, (co.edu.javeriana.isml.isml.Parameter) semanticObject); 
				return; 
			case IsmlPackage.PARAMETERIZED_TYPE:
				sequence_ParameterizedType(context, (ParameterizedType) semanticObject); 
				return; 
			case IsmlPackage.PRIMITIVE:
				sequence_Primitive(context, (Primitive) semanticObject); 
				return; 
			case IsmlPackage.RESOURCE:
				sequence_Resource(context, (Resource) semanticObject); 
				return; 
			case IsmlPackage.RESOURCE_ASSIGNMENT:
				sequence_ResourceAssignment(context, (ResourceAssignment) semanticObject); 
				return; 
			case IsmlPackage.RESOURCE_BUNDLE:
				sequence_ResourceBundle(context, (ResourceBundle) semanticObject); 
				return; 
			case IsmlPackage.RESOURCE_REFERENCE:
				sequence_ResourceReference(context, (ResourceReference) semanticObject); 
				return; 
			case IsmlPackage.SERVICE:
				sequence_Service(context, (Service) semanticObject); 
				return; 
			case IsmlPackage.SHOW:
				sequence_Show(context, (Show) semanticObject); 
				return; 
			case IsmlPackage.STRING_VALUE:
				sequence_StringValue(context, (StringValue) semanticObject); 
				return; 
			case IsmlPackage.STRUCT_INSTANCE:
				sequence_StructInstance(context, (StructInstance) semanticObject); 
				return; 
			case IsmlPackage.TYPE:
				if (rule == grammarAccess.getConstraintTypeRule()) {
					sequence_ConstraintType(context, (Type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getSimpleTypeRule()) {
					sequence_SimpleType(context, (Type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMethodStatementRule()
						|| rule == grammarAccess.getReferenceStatementRule()
						|| action == grammarAccess.getReferenceStatementAccess().getAssignmentLeftAction_1_0()
						|| rule == grammarAccess.getExpressionRule()
						|| action == grammarAccess.getExpressionAccess().getBinaryOperatorLeftAction_1_0()
						|| rule == grammarAccess.getBoolTermRule()
						|| action == grammarAccess.getBoolTermAccess().getBinaryOperatorLeftAction_1_0()
						|| rule == grammarAccess.getNegationRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getBinaryOperatorLeftAction_1_0()
						|| rule == grammarAccess.getArithmeticExpressionRule()
						|| action == grammarAccess.getArithmeticExpressionAccess().getBinaryOperatorLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getBinaryOperatorLeftAction_1_0()
						|| rule == grammarAccess.getNegativeRule()
						|| rule == grammarAccess.getFactorRule()
						|| rule == grammarAccess.getReferenceRule()
						|| rule == grammarAccess.getTypedElementReferenceRule()
						|| rule == grammarAccess.getReferenceTailRule()) {
					sequence_SimpleType_TypedElementReference(context, (Type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getWidgetTypeRule()) {
					sequence_WidgetType(context, (Type) semanticObject); 
					return; 
				}
				else break;
			case IsmlPackage.UNARY_OPERATOR:
				sequence_Negation_Negative(context, (UnaryOperator) semanticObject); 
				return; 
			case IsmlPackage.VARIABLE:
				if (rule == grammarAccess.getForVariableRule()) {
					sequence_ForVariable(context, (Variable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMethodStatementRule()
						|| rule == grammarAccess.getVariableRule()) {
					sequence_Variable(context, (Variable) semanticObject); 
					return; 
				}
				else break;
			case IsmlPackage.VARIABLE_REFERENCE:
				if (rule == grammarAccess.getMethodStatementRule()
						|| rule == grammarAccess.getReferenceStatementRule()
						|| action == grammarAccess.getReferenceStatementAccess().getAssignmentLeftAction_1_0()
						|| rule == grammarAccess.getExpressionRule()
						|| action == grammarAccess.getExpressionAccess().getBinaryOperatorLeftAction_1_0()
						|| rule == grammarAccess.getBoolTermRule()
						|| action == grammarAccess.getBoolTermAccess().getBinaryOperatorLeftAction_1_0()
						|| rule == grammarAccess.getNegationRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getBinaryOperatorLeftAction_1_0()
						|| rule == grammarAccess.getArithmeticExpressionRule()
						|| action == grammarAccess.getArithmeticExpressionAccess().getBinaryOperatorLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getBinaryOperatorLeftAction_1_0()
						|| rule == grammarAccess.getNegativeRule()
						|| rule == grammarAccess.getFactorRule()
						|| rule == grammarAccess.getReferenceRule()
						|| rule == grammarAccess.getTypedElementReferenceRule()
						|| rule == grammarAccess.getReferenceTailRule()) {
					sequence_TypedElementReference_VariableReference(context, (VariableReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableReferenceRule()) {
					sequence_VariableReference(context, (VariableReference) semanticObject); 
					return; 
				}
				else break;
			case IsmlPackage.VIEW_INSTANCE:
				if (rule == grammarAccess.getViewInstanceNoActionRule()) {
					sequence_ViewInstanceNoAction(context, (ViewInstance) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getViewStatementRule()
						|| rule == grammarAccess.getViewInstanceRule()) {
					sequence_ViewInstance_ViewInstanceNoAction(context, (ViewInstance) semanticObject); 
					return; 
				}
				else break;
			case IsmlPackage.WHILE:
				sequence_While(context, (While) semanticObject); 
				return; 
			case IsmlPackage.WIDGET:
				sequence_Widget(context, (Widget) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ActionCall returns ActionCall
	 *     ActionCallStatement returns ActionCall
	 *     MethodStatement returns ActionCall
	 *
	 * Constraint:
	 *     (referencedElement=[Action|QualifiedName] (parameters+=Expression parameters+=Expression*)?)
	 */
	protected void sequence_ActionCall(ISerializationContext context, ActionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Action
	 *     Function returns Action
	 *
	 * Constraint:
	 *     (
	 *         (default?='default'? name=LOWER_CASE_ID (parameters+=Parameter parameters+=Parameter*)? body+=MethodStatement*) | 
	 *         (native?='native' default?='default'? name=LOWER_CASE_ID (parameters+=Parameter parameters+=Parameter*)?)
	 *     )
	 */
	protected void sequence_Action(ISerializationContext context, co.edu.javeriana.isml.isml.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSpecification returns Actor
	 *     Actor returns Actor
	 *
	 * Constraint:
	 *     (name=UPPER_CASE_ID (superTypes+=Type superTypes+=Type*)? (hasBody?='{' body+=Attribute*)?)
	 */
	protected void sequence_Actor(ISerializationContext context, Actor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BinaryOperator
	 *     Expression.BinaryOperator_1_0 returns BinaryOperator
	 *     BoolTerm returns BinaryOperator
	 *     BoolTerm.BinaryOperator_1_0 returns BinaryOperator
	 *     Negation returns BinaryOperator
	 *     Comparison returns BinaryOperator
	 *     Comparison.BinaryOperator_1_0 returns BinaryOperator
	 *     ArithmeticExpression returns BinaryOperator
	 *     ArithmeticExpression.BinaryOperator_1_0 returns BinaryOperator
	 *     Term returns BinaryOperator
	 *     Term.BinaryOperator_1_0 returns BinaryOperator
	 *     Negative returns BinaryOperator
	 *     Factor returns BinaryOperator
	 *
	 * Constraint:
	 *     (
	 *         (left=Expression_BinaryOperator_1_0 symbol='||' right=BoolTerm) | 
	 *         (left=BoolTerm_BinaryOperator_1_0 symbol='&&' right=Negation) | 
	 *         (
	 *             left=Comparison_BinaryOperator_1_0 
	 *             (
	 *                 symbol='<=' | 
	 *                 symbol='>=' | 
	 *                 symbol='>' | 
	 *                 symbol='<' | 
	 *                 symbol='!=' | 
	 *                 symbol='==' | 
	 *                 symbol='is' | 
	 *                 symbol='as'
	 *             ) 
	 *             right=ArithmeticExpression
	 *         ) | 
	 *         (left=ArithmeticExpression_BinaryOperator_1_0 (symbol='+' | symbol='-') right=Term) | 
	 *         (left=Term_BinaryOperator_1_0 (symbol='*' | symbol='/' | symbol='%') right=Negative)
	 *     )
	 */
	protected void sequence_ArithmeticExpression_BoolTerm_Comparison_Expression_Term(ISerializationContext context, BinaryOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (type=Type name=LOWER_CASE_ID (constraints+=ConstraintInstance constraints+=ConstraintInstance*)? opposite=[Attribute|QualifiedName]?)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BoolValue
	 *     Expression.BinaryOperator_1_0 returns BoolValue
	 *     BoolTerm returns BoolValue
	 *     BoolTerm.BinaryOperator_1_0 returns BoolValue
	 *     Negation returns BoolValue
	 *     Comparison returns BoolValue
	 *     Comparison.BinaryOperator_1_0 returns BoolValue
	 *     ArithmeticExpression returns BoolValue
	 *     ArithmeticExpression.BinaryOperator_1_0 returns BoolValue
	 *     Term returns BoolValue
	 *     Term.BinaryOperator_1_0 returns BoolValue
	 *     Negative returns BoolValue
	 *     Factor returns BoolValue
	 *     LiteralValue returns BoolValue
	 *     BoolValue returns BoolValue
	 *
	 * Constraint:
	 *     (literal='true' | literal='false')
	 */
	protected void sequence_BoolValue(ISerializationContext context, BoolValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintInstance returns ConstraintInstance
	 *
	 * Constraint:
	 *     (type=ConstraintType (parameters+=Expression parameters+=Expression*)?)
	 */
	protected void sequence_ConstraintInstance(ISerializationContext context, ConstraintInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintType returns Type
	 *
	 * Constraint:
	 *     referencedElement=[Constraint|UPPER_CASE_ID]
	 */
	protected void sequence_ConstraintType(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.REFERENCE__REFERENCED_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.REFERENCE__REFERENCED_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstraintTypeAccess().getReferencedElementConstraintUPPER_CASE_IDTerminalRuleCall_0_1(), semanticObject.eGet(IsmlPackage.Literals.REFERENCE__REFERENCED_ELEMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (name=UPPER_CASE_ID (parameters+=Parameter parameters+=Parameter*)?)
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSpecification returns Controller
	 *     Controller returns Controller
	 *
	 * Constraint:
	 *     (name=UPPER_CASE_ID (hasBody?='{' (body+=ServiceAttribute | body+=Action)*)?)
	 */
	protected void sequence_Controller(ISerializationContext context, Controller semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DTOAttribute returns Attribute
	 *
	 * Constraint:
	 *     (type=Type name=LOWER_CASE_ID)
	 */
	protected void sequence_DTOAttribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.TYPED_ELEMENT__TYPE));
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDTOAttributeAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getDTOAttributeAccess().getNameLOWER_CASE_IDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DTO returns DTO
	 *
	 * Constraint:
	 *     (name=UPPER_CASE_ID (superTypes+=Type superTypes+=Type*)? (hasBody?='{' body+=DTOAttribute*)?)
	 */
	protected void sequence_DTO(ISerializationContext context, DTO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Entity
	 *     TypeSpecification returns Entity
	 *
	 * Constraint:
	 *     (abstract?='abstract'? name=UPPER_CASE_ID (superTypes+=Type superTypes+=Type*)? (hasBody?='{' body+=Attribute*)?)
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumItem returns EnumItem
	 *
	 * Constraint:
	 *     name=LOWER_CASE_ID
	 */
	protected void sequence_EnumItem(ISerializationContext context, EnumItem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumItemAccess().getNameLOWER_CASE_IDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Enum returns Enum
	 *
	 * Constraint:
	 *     (name=UPPER_CASE_ID body+=EnumItem body+=EnumItem*)
	 */
	protected void sequence_Enum(ISerializationContext context, co.edu.javeriana.isml.isml.Enum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FloatValue
	 *     Expression.BinaryOperator_1_0 returns FloatValue
	 *     BoolTerm returns FloatValue
	 *     BoolTerm.BinaryOperator_1_0 returns FloatValue
	 *     Negation returns FloatValue
	 *     Comparison returns FloatValue
	 *     Comparison.BinaryOperator_1_0 returns FloatValue
	 *     ArithmeticExpression returns FloatValue
	 *     ArithmeticExpression.BinaryOperator_1_0 returns FloatValue
	 *     Term returns FloatValue
	 *     Term.BinaryOperator_1_0 returns FloatValue
	 *     Negative returns FloatValue
	 *     Factor returns FloatValue
	 *     LiteralValue returns FloatValue
	 *     FloatValue returns FloatValue
	 *
	 * Constraint:
	 *     literal=Decimal
	 */
	protected void sequence_FloatValue(ISerializationContext context, FloatValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.LITERAL_VALUE__LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.LITERAL_VALUE__LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFloatValueAccess().getLiteralDecimalParserRuleCall_0(), semanticObject.getLiteral());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ForVariable returns Variable
	 *
	 * Constraint:
	 *     (type=Type name=LOWER_CASE_ID)
	 */
	protected void sequence_ForVariable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.TYPED_ELEMENT__TYPE));
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForVariableAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getForVariableAccess().getNameLOWER_CASE_IDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ViewStatement returns ForView
	 *     ForView returns ForView
	 *
	 * Constraint:
	 *     (variable=ForVariable collection=Reference ((hasBody?='{' body+=ViewStatement*) | body+=ViewStatement))
	 */
	protected void sequence_ForView(ISerializationContext context, ForView semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodStatement returns For
	 *     For returns For
	 *
	 * Constraint:
	 *     (variable=Variable collection=Reference ((hasBody?='{' body+=MethodStatement*) | body+=MethodStatement))
	 */
	protected void sequence_For(ISerializationContext context, For semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenericTypeSpecification returns GenericTypeSpecification
	 *
	 * Constraint:
	 *     (name=UPPER_CASE_ID superType=Type?)
	 */
	protected void sequence_GenericTypeSpecification(ISerializationContext context, GenericTypeSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ViewStatement returns IfView
	 *     IfView returns IfView
	 *
	 * Constraint:
	 *     (condition=Expression ((hasBody?='{' body+=ViewStatement*) | body+=ViewStatement))
	 */
	protected void sequence_IfView(ISerializationContext context, IfView semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodStatement returns If
	 *     If returns If
	 *
	 * Constraint:
	 *     (condition=Expression ((hasBody?='{' body+=MethodStatement*) | body+=MethodStatement) (elseBody+=MethodStatement+ | elseBody+=MethodStatement)?)
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedPackage=[Package|QualifiedName]
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.IMPORT__IMPORTED_PACKAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.IMPORT__IMPORTED_PACKAGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedPackagePackageQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(IsmlPackage.Literals.IMPORT__IMPORTED_PACKAGE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InformationSystem returns InformationSystem
	 *
	 * Constraint:
	 *     body+=Package+
	 */
	protected void sequence_InformationSystem(ISerializationContext context, InformationSystem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntValue
	 *     Expression.BinaryOperator_1_0 returns IntValue
	 *     BoolTerm returns IntValue
	 *     BoolTerm.BinaryOperator_1_0 returns IntValue
	 *     Negation returns IntValue
	 *     Comparison returns IntValue
	 *     Comparison.BinaryOperator_1_0 returns IntValue
	 *     ArithmeticExpression returns IntValue
	 *     ArithmeticExpression.BinaryOperator_1_0 returns IntValue
	 *     Term returns IntValue
	 *     Term.BinaryOperator_1_0 returns IntValue
	 *     Negative returns IntValue
	 *     Factor returns IntValue
	 *     LiteralValue returns IntValue
	 *     IntValue returns IntValue
	 *
	 * Constraint:
	 *     literal=INT
	 */
	protected void sequence_IntValue(ISerializationContext context, IntValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.LITERAL_VALUE__LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.LITERAL_VALUE__LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntValueAccess().getLiteralINTTerminalRuleCall_0(), semanticObject.getLiteral());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MethodCall returns MethodCall
	 *
	 * Constraint:
	 *     (referencedElement=[Method|LOWER_CASE_ID] (parameters+=Expression parameters+=Expression*)?)
	 */
	protected void sequence_MethodCall(ISerializationContext context, MethodCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodStatement returns MethodCall
	 *     ReferenceStatement returns MethodCall
	 *     ReferenceStatement.Assignment_1_0 returns MethodCall
	 *     Expression returns MethodCall
	 *     Expression.BinaryOperator_1_0 returns MethodCall
	 *     BoolTerm returns MethodCall
	 *     BoolTerm.BinaryOperator_1_0 returns MethodCall
	 *     Negation returns MethodCall
	 *     Comparison returns MethodCall
	 *     Comparison.BinaryOperator_1_0 returns MethodCall
	 *     ArithmeticExpression returns MethodCall
	 *     ArithmeticExpression.BinaryOperator_1_0 returns MethodCall
	 *     Term returns MethodCall
	 *     Term.BinaryOperator_1_0 returns MethodCall
	 *     Negative returns MethodCall
	 *     Factor returns MethodCall
	 *     Reference returns MethodCall
	 *     TypedElementReference returns MethodCall
	 *     ReferenceTail returns MethodCall
	 *
	 * Constraint:
	 *     (referencedElement=[Method|LOWER_CASE_ID] (parameters+=Expression parameters+=Expression*)? tail=ReferenceTail?)
	 */
	protected void sequence_MethodCall_TypedElementReference(ISerializationContext context, MethodCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ViewStatement returns NamedViewBlock
	 *     NamedViewBlock returns NamedViewBlock
	 *
	 * Constraint:
	 *     (name=LOWER_CASE_ID ((hasBody?='{' body+=ViewStatement*) | body+=ViewStatement))
	 */
	protected void sequence_NamedViewBlock(ISerializationContext context, NamedViewBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NativeMethod returns Method
	 *
	 * Constraint:
	 *     (
	 *         native?='native' 
	 *         (genericTypeParameters+=GenericTypeSpecification genericTypeParameters+=GenericTypeSpecification*)? 
	 *         type=Type 
	 *         name=LOWER_CASE_ID 
	 *         (parameters+=Parameter parameters+=Parameter*)?
	 *     )
	 */
	protected void sequence_NativeMethod(ISerializationContext context, Method semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Feature returns Method
	 *     Method returns Method
	 *     Function returns Method
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             native?='native' 
	 *             (genericTypeParameters+=GenericTypeSpecification genericTypeParameters+=GenericTypeSpecification*)? 
	 *             type=Type 
	 *             name=LOWER_CASE_ID 
	 *             (parameters+=Parameter parameters+=Parameter*)?
	 *         ) | 
	 *         (
	 *             (genericTypeParameters+=GenericTypeSpecification genericTypeParameters+=GenericTypeSpecification*)? 
	 *             type=Type 
	 *             name=LOWER_CASE_ID 
	 *             (parameters+=Parameter parameters+=Parameter*)? 
	 *             (hasBody?='{' body+=MethodStatement*)?
	 *         )
	 *     )
	 */
	protected void sequence_NativeMethod_RegularMethod(ISerializationContext context, Method semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns UnaryOperator
	 *     Expression.BinaryOperator_1_0 returns UnaryOperator
	 *     BoolTerm returns UnaryOperator
	 *     BoolTerm.BinaryOperator_1_0 returns UnaryOperator
	 *     Negation returns UnaryOperator
	 *     Comparison returns UnaryOperator
	 *     Comparison.BinaryOperator_1_0 returns UnaryOperator
	 *     ArithmeticExpression returns UnaryOperator
	 *     ArithmeticExpression.BinaryOperator_1_0 returns UnaryOperator
	 *     Term returns UnaryOperator
	 *     Term.BinaryOperator_1_0 returns UnaryOperator
	 *     Negative returns UnaryOperator
	 *     Factor returns UnaryOperator
	 *
	 * Constraint:
	 *     ((symbol='!' expression=Negation) | expression=Negative)
	 */
	protected void sequence_Negation_Negative(ISerializationContext context, UnaryOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NullValue
	 *     Expression.BinaryOperator_1_0 returns NullValue
	 *     BoolTerm returns NullValue
	 *     BoolTerm.BinaryOperator_1_0 returns NullValue
	 *     Negation returns NullValue
	 *     Comparison returns NullValue
	 *     Comparison.BinaryOperator_1_0 returns NullValue
	 *     ArithmeticExpression returns NullValue
	 *     ArithmeticExpression.BinaryOperator_1_0 returns NullValue
	 *     Term returns NullValue
	 *     Term.BinaryOperator_1_0 returns NullValue
	 *     Negative returns NullValue
	 *     Factor returns NullValue
	 *     LiteralValue returns NullValue
	 *     NullValue returns NullValue
	 *
	 * Constraint:
	 *     literal='null'
	 */
	protected void sequence_NullValue(ISerializationContext context, NullValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.LITERAL_VALUE__LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.LITERAL_VALUE__LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNullValueAccess().getLiteralNullKeyword_0(), semanticObject.getLiteral());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Package returns Package
	 *
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         imports+=Import* 
	 *         (hasBody?='{' body+=Resource*)? 
	 *         (
	 *             body+=Entity | 
	 *             body+=DTO | 
	 *             body+=View | 
	 *             body+=Controller | 
	 *             body+=Primitive | 
	 *             body+=Constraint | 
	 *             body+=ResourceBundle | 
	 *             body+=Actor | 
	 *             body+=Service | 
	 *             body+=Enum
	 *         )*
	 *     )
	 */
	protected void sequence_Package(ISerializationContext context, co.edu.javeriana.isml.isml.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSpecification returns Page
	 *     View returns Page
	 *     Page returns Page
	 *
	 * Constraint:
	 *     (name=UPPER_CASE_ID (parameters+=Parameter parameters+=Parameter*)? controller=[Controller|QualifiedName] (hasBody?='{' body+=ViewStatement*)?)
	 */
	protected void sequence_Page(ISerializationContext context, Page semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (type=Type name=LOWER_CASE_ID)
	 */
	protected void sequence_Parameter(ISerializationContext context, co.edu.javeriana.isml.isml.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.TYPED_ELEMENT__TYPE));
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getParameterAccess().getNameLOWER_CASE_IDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ParameterizedType
	 *     ParameterizedType returns ParameterizedType
	 *
	 * Constraint:
	 *     (referencedElement=[TypeSpecification|UPPER_CASE_ID] typeParameters+=Type typeParameters+=Type*)
	 */
	protected void sequence_ParameterizedType(ISerializationContext context, ParameterizedType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSpecification returns Primitive
	 *     Primitive returns Primitive
	 *
	 * Constraint:
	 *     (
	 *         abstract?='abstract'? 
	 *         name=UPPER_CASE_ID 
	 *         (genericTypeParameters+=GenericTypeSpecification genericTypeParameters+=GenericTypeSpecification*)? 
	 *         superTypes+=Type?
	 *     )
	 */
	protected void sequence_Primitive(ISerializationContext context, Primitive semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodStatement returns Assignment
	 *     ReferenceStatement returns Assignment
	 *
	 * Constraint:
	 *     (left=ReferenceStatement_Assignment_1_0 (symbol='=' | symbol='+=' | symbol='-=' | symbol='*=' | symbol='/=') right=Expression)
	 */
	protected void sequence_ReferenceStatement(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegularMethod returns Method
	 *
	 * Constraint:
	 *     (
	 *         (genericTypeParameters+=GenericTypeSpecification genericTypeParameters+=GenericTypeSpecification*)? 
	 *         type=Type 
	 *         name=LOWER_CASE_ID 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (hasBody?='{' body+=MethodStatement*)?
	 *     )
	 */
	protected void sequence_RegularMethod(ISerializationContext context, Method semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ResourceAssignment returns ResourceAssignment
	 *
	 * Constraint:
	 *     (left=ResourceReference right=StringValue)
	 */
	protected void sequence_ResourceAssignment(ISerializationContext context, ResourceAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getResourceAssignmentAccess().getLeftResourceReferenceParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getResourceAssignmentAccess().getRightStringValueParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ResourceBundle returns ResourceBundle
	 *     TypeSpecification returns ResourceBundle
	 *
	 * Constraint:
	 *     (name=UPPER_CASE_ID body+=ResourceAssignment*)
	 */
	protected void sequence_ResourceBundle(ISerializationContext context, ResourceBundle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodStatement returns ResourceReference
	 *     ReferenceStatement returns ResourceReference
	 *     ReferenceStatement.Assignment_1_0 returns ResourceReference
	 *     Expression returns ResourceReference
	 *     Expression.BinaryOperator_1_0 returns ResourceReference
	 *     BoolTerm returns ResourceReference
	 *     BoolTerm.BinaryOperator_1_0 returns ResourceReference
	 *     Negation returns ResourceReference
	 *     Comparison returns ResourceReference
	 *     Comparison.BinaryOperator_1_0 returns ResourceReference
	 *     ArithmeticExpression returns ResourceReference
	 *     ArithmeticExpression.BinaryOperator_1_0 returns ResourceReference
	 *     Term returns ResourceReference
	 *     Term.BinaryOperator_1_0 returns ResourceReference
	 *     Negative returns ResourceReference
	 *     Factor returns ResourceReference
	 *     Reference returns ResourceReference
	 *     ResourceReference returns ResourceReference
	 *
	 * Constraint:
	 *     referencedElement=[Resource|ResourceName]
	 */
	protected void sequence_ResourceReference(ISerializationContext context, ResourceReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.REFERENCE__REFERENCED_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.REFERENCE__REFERENCED_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getResourceReferenceAccess().getReferencedElementResourceResourceNameParserRuleCall_0_1(), semanticObject.eGet(IsmlPackage.Literals.REFERENCE__REFERENCED_ELEMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Resource returns Resource
	 *
	 * Constraint:
	 *     name=ResourceName
	 */
	protected void sequence_Resource(ISerializationContext context, Resource semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getResourceAccess().getNameResourceNameParserRuleCall_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Feature returns Attribute
	 *     ServiceAttribute returns Attribute
	 *
	 * Constraint:
	 *     (type=Type name=LOWER_CASE_ID?)
	 */
	protected void sequence_ServiceAttribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Service returns Service
	 *
	 * Constraint:
	 *     (
	 *         name=UPPER_CASE_ID 
	 *         (genericTypeParameters+=GenericTypeSpecification genericTypeParameters+=GenericTypeSpecification*)? 
	 *         superTypes+=Type? 
	 *         hasBody?='{' 
	 *         body+=Feature*
	 *     )
	 */
	protected void sequence_Service(ISerializationContext context, Service semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodStatement returns Show
	 *     Show returns Show
	 *
	 * Constraint:
	 *     expression=ViewInstanceNoAction
	 */
	protected void sequence_Show(ISerializationContext context, Show semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.SHOW__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.SHOW__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShowAccess().getExpressionViewInstanceNoActionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *     SimpleType returns Type
	 *
	 * Constraint:
	 *     referencedElement=[TypeSpecification|UPPER_CASE_ID]
	 */
	protected void sequence_SimpleType(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.REFERENCE__REFERENCED_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.REFERENCE__REFERENCED_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleTypeAccess().getReferencedElementTypeSpecificationUPPER_CASE_IDTerminalRuleCall_0_1(), semanticObject.eGet(IsmlPackage.Literals.REFERENCE__REFERENCED_ELEMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MethodStatement returns Type
	 *     ReferenceStatement returns Type
	 *     ReferenceStatement.Assignment_1_0 returns Type
	 *     Expression returns Type
	 *     Expression.BinaryOperator_1_0 returns Type
	 *     BoolTerm returns Type
	 *     BoolTerm.BinaryOperator_1_0 returns Type
	 *     Negation returns Type
	 *     Comparison returns Type
	 *     Comparison.BinaryOperator_1_0 returns Type
	 *     ArithmeticExpression returns Type
	 *     ArithmeticExpression.BinaryOperator_1_0 returns Type
	 *     Term returns Type
	 *     Term.BinaryOperator_1_0 returns Type
	 *     Negative returns Type
	 *     Factor returns Type
	 *     Reference returns Type
	 *     TypedElementReference returns Type
	 *     ReferenceTail returns Type
	 *
	 * Constraint:
	 *     (referencedElement=[TypeSpecification|UPPER_CASE_ID] tail=ReferenceTail?)
	 */
	protected void sequence_SimpleType_TypedElementReference(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringValue
	 *     Expression.BinaryOperator_1_0 returns StringValue
	 *     BoolTerm returns StringValue
	 *     BoolTerm.BinaryOperator_1_0 returns StringValue
	 *     Negation returns StringValue
	 *     Comparison returns StringValue
	 *     Comparison.BinaryOperator_1_0 returns StringValue
	 *     ArithmeticExpression returns StringValue
	 *     ArithmeticExpression.BinaryOperator_1_0 returns StringValue
	 *     Term returns StringValue
	 *     Term.BinaryOperator_1_0 returns StringValue
	 *     Negative returns StringValue
	 *     Factor returns StringValue
	 *     LiteralValue returns StringValue
	 *     StringValue returns StringValue
	 *
	 * Constraint:
	 *     literal=STRING
	 */
	protected void sequence_StringValue(ISerializationContext context, StringValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.LITERAL_VALUE__LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.LITERAL_VALUE__LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringValueAccess().getLiteralSTRINGTerminalRuleCall_0(), semanticObject.getLiteral());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StructInstance
	 *     Expression.BinaryOperator_1_0 returns StructInstance
	 *     BoolTerm returns StructInstance
	 *     BoolTerm.BinaryOperator_1_0 returns StructInstance
	 *     Negation returns StructInstance
	 *     Comparison returns StructInstance
	 *     Comparison.BinaryOperator_1_0 returns StructInstance
	 *     ArithmeticExpression returns StructInstance
	 *     ArithmeticExpression.BinaryOperator_1_0 returns StructInstance
	 *     Term returns StructInstance
	 *     Term.BinaryOperator_1_0 returns StructInstance
	 *     Negative returns StructInstance
	 *     Factor returns StructInstance
	 *     StructInstance returns StructInstance
	 *
	 * Constraint:
	 *     (type=Type (parameters+=Expression parameters+=Expression*)?)
	 */
	protected void sequence_StructInstance(ISerializationContext context, StructInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodStatement returns VariableReference
	 *     ReferenceStatement returns VariableReference
	 *     ReferenceStatement.Assignment_1_0 returns VariableReference
	 *     Expression returns VariableReference
	 *     Expression.BinaryOperator_1_0 returns VariableReference
	 *     BoolTerm returns VariableReference
	 *     BoolTerm.BinaryOperator_1_0 returns VariableReference
	 *     Negation returns VariableReference
	 *     Comparison returns VariableReference
	 *     Comparison.BinaryOperator_1_0 returns VariableReference
	 *     ArithmeticExpression returns VariableReference
	 *     ArithmeticExpression.BinaryOperator_1_0 returns VariableReference
	 *     Term returns VariableReference
	 *     Term.BinaryOperator_1_0 returns VariableReference
	 *     Negative returns VariableReference
	 *     Factor returns VariableReference
	 *     Reference returns VariableReference
	 *     TypedElementReference returns VariableReference
	 *     ReferenceTail returns VariableReference
	 *
	 * Constraint:
	 *     (referencedElement=[VariableTypeElement|LOWER_CASE_ID] tail=ReferenceTail?)
	 */
	protected void sequence_TypedElementReference_VariableReference(ISerializationContext context, VariableReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableReference returns VariableReference
	 *
	 * Constraint:
	 *     referencedElement=[VariableTypeElement|LOWER_CASE_ID]
	 */
	protected void sequence_VariableReference(ISerializationContext context, VariableReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.REFERENCE__REFERENCED_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.REFERENCE__REFERENCED_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableReferenceAccess().getReferencedElementVariableTypeElementLOWER_CASE_IDTerminalRuleCall_1_0_1(), semanticObject.eGet(IsmlPackage.Literals.REFERENCE__REFERENCED_ELEMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MethodStatement returns Variable
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (type=Type name=LOWER_CASE_ID value=Expression?)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ViewInstanceNoAction returns ViewInstance
	 *
	 * Constraint:
	 *     (name=LOWER_CASE_ID? type=WidgetType (parameters+=Expression parameters+=Expression*)?)
	 */
	protected void sequence_ViewInstanceNoAction(ISerializationContext context, ViewInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ViewStatement returns ViewInstance
	 *     ViewInstance returns ViewInstance
	 *
	 * Constraint:
	 *     (
	 *         name=LOWER_CASE_ID? 
	 *         type=WidgetType 
	 *         (parameters+=Expression parameters+=Expression*)? 
	 *         actionCall=ActionCall? 
	 *         (hasBody?='{' body+=ViewStatement*)?
	 *     )
	 */
	protected void sequence_ViewInstance_ViewInstanceNoAction(ISerializationContext context, ViewInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodStatement returns While
	 *     While returns While
	 *
	 * Constraint:
	 *     (condition=Expression ((hasBody?='{' body+=MethodStatement*) | body+=MethodStatement))
	 */
	protected void sequence_While(ISerializationContext context, While semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WidgetType returns Type
	 *
	 * Constraint:
	 *     referencedElement=[Widget|UPPER_CASE_ID]
	 */
	protected void sequence_WidgetType(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IsmlPackage.Literals.REFERENCE__REFERENCED_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IsmlPackage.Literals.REFERENCE__REFERENCED_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWidgetTypeAccess().getReferencedElementWidgetUPPER_CASE_IDTerminalRuleCall_0_1(), semanticObject.eGet(IsmlPackage.Literals.REFERENCE__REFERENCED_ELEMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeSpecification returns Widget
	 *     View returns Widget
	 *     Widget returns Widget
	 *
	 * Constraint:
	 *     (name=UPPER_CASE_ID (parameters+=Parameter parameters+=Parameter*)? controller=[Controller|QualifiedName]? (hasBody?='{' body+=ViewStatement*)?)
	 */
	protected void sequence_Widget(ISerializationContext context, Widget semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
