package co.edu.javeriana.isml.generator.test;

import co.edu.javeriana.isml.generator.common.SimpleTemplate;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.junit.Assert;

@SuppressWarnings("all")
public class TestGeneratorHelper {
  /**
   * Verifies whether a templates generates the expected output code from a given input model element. Both the
   * generated code and the expected output code strings are processed to remove excess whitespaces and to
   * add spaces both before and after any non alphabetic character. This should facilitate comparison between expected output
   * and generated code, since the programmer does not have to worry about whitespaces.
   * To force a 1-to-1 comparison, utilize the method {@link TestGeneratorHelper#assertGeneratesVerbatim}
   * @param template The template
   * @param input The input model element. This element is fed to the template to generate code
   * @param expectedOutput The expected code to be generated by the template
   */
  public <T extends EObject> void assertGenerates(final SimpleTemplate<T> template, final T input, final CharSequence expectedOutput) {
    final CharSequence generatedText = template.toText(input);
    final String trimmedGeneratedText = this.trimUnwantedChars(generatedText);
    final String trimmedExpectedOutput = this.trimUnwantedChars(expectedOutput);
    this.compare(trimmedGeneratedText, trimmedExpectedOutput, expectedOutput);
  }
  
  /**
   * Verifies whether a templates generates the expected output code from a given input model element. The expected
   * output must be <b>exactly</b> the same as the generated code, otherwise the assertion fails.
   * @param template The template
   * @param input The input model element. This element is fed to the template to generate code
   * @param expectedOutput The expected code to be generated by the template
   */
  public <T extends EObject> void assertGeneratesVerbatim(final SimpleTemplate<T> template, final T input, final CharSequence expectedOutput) {
    final CharSequence generatedText = template.toText(input);
    final String trimmedGeneratedText = this.trimUnwantedChars(generatedText);
    final String trimmedExpectedOutput = this.trimUnwantedChars(expectedOutput);
    this.compare(trimmedGeneratedText, trimmedExpectedOutput, expectedOutput);
  }
  
  public void compare(final String trimmedGeneratedText, final String trimmedExpectedOutput, final CharSequence expectedOutput) {
    boolean _equals = trimmedGeneratedText.equals(trimmedExpectedOutput);
    boolean _not = (!_equals);
    if (_not) {
      this.printCallingMethod();
      InputOutput.<String>println((("\nExpected output:\n\"" + trimmedExpectedOutput) + "\""));
      InputOutput.<String>println((("Generated code: \n\"" + trimmedGeneratedText) + "\""));
      final int diffPos = this.findDiffPos(trimmedExpectedOutput, trimmedGeneratedText);
      final String expectedPortion = this.getSurroundingString(trimmedExpectedOutput, diffPos);
      final String generatedPortion = this.getSurroundingString(trimmedGeneratedText, diffPos);
      InputOutput.<String>println(("\nThe difference is at position " + Integer.valueOf(diffPos)));
      InputOutput.<String>println(expectedPortion);
      InputOutput.<String>println(generatedPortion);
      Assert.fail(((("Incorrect generated text. Expected: \n" + expectedOutput) + "\n\nbut got:\n") + trimmedGeneratedText));
    }
  }
  
  /**
   * @returns the position where two strings are different, -1 if both are equal
   */
  public int findDiffPos(final String string, final String string2) {
    final int length = Math.min(string.length(), string2.length());
    int i = 0;
    while ((i < length)) {
      {
        char _charAt = string.charAt(i);
        char _charAt_1 = string2.charAt(i);
        boolean _notEquals = (_charAt != _charAt_1);
        if (_notEquals) {
          return i;
        }
        i++;
      }
    }
    int _length = string.length();
    int _length_1 = string2.length();
    boolean _notEquals = (_length != _length_1);
    if (_notEquals) {
      return i;
    }
    return (-1);
  }
  
  public String getSurroundingString(final String str, final int pos) {
    final int start = Math.max((pos - 40), 0);
    final int end = Math.min((pos + 40), str.length());
    return str.substring(start, end);
  }
  
  public String printCallingMethod() {
    return InputOutput.<String>println(Thread.currentThread().getStackTrace()[2].getMethodName());
  }
  
  public String trimUnwantedChars(final CharSequence seq) {
    return String.valueOf(seq).replaceAll("[^A-Za-z]", " $0 ").replaceAll("\\s+", " ").trim();
  }
}
